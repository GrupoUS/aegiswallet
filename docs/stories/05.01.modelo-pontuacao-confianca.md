# Story 05.01: Modelo de Pontuação de Confiança

## Status
**Current Status:** Approved
**Epic:** 05 - Autonomous Financial Intelligence  
**Priority:** Future  
**Estimated Effort:** 5 days  
**Dependencies:** Banking data pipeline, User behavior analytics, ML infrastructure

---

## Story

**As a** usuário do AegisWallet,  
**I want** que o sistema aprenda meus padrões financeiros e construa confiança gradualmente,  
**so that** eu possa aumentar progressivamente o nível de autonomia do sistema conforme me sinto mais confortável.

---

## Acceptance Criteria

1. [ ] Algoritmo de scoring baseado em histórico, consistência e feedback
2. [ ] Níveis de confiança: Iniciante (50%), Intermediário (75%), Avançado (95%)
3. [ ] Dashboard para usuário visualizar e ajustar seu nível de confiança
4. [ ] Recomendações automáticas para aumentar autonomia baseadas em comportamento
5. [ ] Sistema de degradação de confiança em caso de erros ou mudanças de padrão
6. [ ] Precisão de predição de comportamento ≥85%
7. [ ] Tempo de cálculo de score <100ms
8. [ ] Transparência completa sobre fatores que influenciam o score

---

## Tasks / Subtasks

- [ ] **Algoritmo de Scoring de Confiança** (AC: 1, 6)
  - [ ] Definir fatores de confiança (histórico, consistência, feedback)
  - [ ] Implementar pesos dinâmicos por categoria de transação
  - [ ] Criar modelo de machine learning para predição
  - [ ] Adicionar normalização por perfil de usuário
  - [ ] Configurar validação cruzada do modelo

- [ ] **Sistema de Níveis de Autonomia** (AC: 2)
  - [ ] Implementar lógica de progressão 50% → 75% → 95%
  - [ ] Criar critérios específicos para cada nível
  - [ ] Adicionar limites de valor por nível de confiança
  - [ ] Configurar workflows de aprovação por nível
  - [ ] Implementar transições automáticas e manuais

- [ ] **Dashboard de Confiança** (AC: 3, 8)
  - [ ] Criar interface para visualização do score atual
  - [ ] Implementar gráficos de evolução temporal
  - [ ] Adicionar explicação dos fatores de influência
  - [ ] Configurar controles para ajuste manual
  - [ ] Implementar simulador de impacto de mudanças

- [ ] **Sistema de Recomendações** (AC: 4)
  - [ ] Implementar engine de recomendações personalizadas
  - [ ] Criar sugestões baseadas em padrões similares
  - [ ] Adicionar timing inteligente para sugestões
  - [ ] Configurar A/B testing para recomendações
  - [ ] Implementar feedback loop para melhoria

- [ ] **Sistema de Degradação e Recuperação** (AC: 5, 7)
  - [ ] Implementar detecção de mudanças de padrão
  - [ ] Configurar degradação automática por erros
  - [ ] Adicionar sistema de recuperação gradual
  - [ ] Implementar alertas para degradação significativa
  - [ ] Otimizar cálculos para <100ms de resposta

---

## Dev Notes

### Arquitetura Relevante

**Estrutura Atual:**
- `src/server/procedures/` - APIs tRPC existentes
- `supabase/` - Database com dados transacionais
- `src/hooks/` - Hooks React para estado

**Novos Arquivos Necessários:**
- `src/lib/ml/trustScoring.ts` - Algoritmo de scoring detalhado
- `src/lib/ml/behaviorAnalyzer.ts` - Análise comportamental
- `src/components/trust/TrustDashboard.tsx` - Dashboard de confiança
- `src/hooks/useTrustScore.ts` - Hook para score de confiança
- `src/server/procedures/trust.ts` - APIs de confiança

### Algoritmo de Scoring Detalhado

**Fatores Específicos e Pesos:**
```typescript
// src/lib/ml/trustScoring.ts
interface TrustFactors {
  consistency: number;      // 30% - Consistência comportamental
  accuracy: number;         // 25% - Precisão das decisões aceitas
  timeUsing: number;        // 20% - Tempo de uso do sistema
  feedbackQuality: number;  // 15% - Qualidade do feedback fornecido
  errorRecovery: number;    // 10% - Capacidade de recuperação de erros
}

interface TrustWeights {
  consistency: 0.30;
  accuracy: 0.25;
  timeUsing: 0.20;
  feedbackQuality: 0.15;
  errorRecovery: 0.10;
}

interface TrustCalculationContext {
  userId: string;
  timeWindow: number; // dias para análise
  transactionHistory: Transaction[];
  feedbackHistory: UserFeedback[];
  errorHistory: SystemError[];
  userBehaviorPatterns: BehaviorPattern[];
}

class TrustScoreCalculator {
  private weights: TrustWeights = {
    consistency: 0.30,
    accuracy: 0.25,
    timeUsing: 0.20,
    feedbackQuality: 0.15,
    errorRecovery: 0.10
  };

  async calculateTrustScore(context: TrustCalculationContext): Promise<TrustScore> {
    // 1. Calcular cada fator individualmente
    const factors = await this.calculateFactors(context);

    // 2. Aplicar pesos e calcular score final
    const weightedScore = this.applyWeights(factors);

    // 3. Determinar nível de autonomia
    const autonomyLevel = this.determineAutonomyLevel(weightedScore);

    // 4. Calcular limites baseados no score
    const limits = this.calculateLimits(weightedScore, autonomyLevel);

    return {
      currentScore: Math.round(weightedScore * 100) / 100,
      autonomyLevel,
      factors,
      limits,
      calculatedAt: new Date(),
      nextRecalculation: this.getNextRecalculationDate()
    };
  }

  private async calculateFactors(context: TrustCalculationContext): Promise<TrustFactors> {
    return {
      consistency: await this.calculateConsistency(context),
      accuracy: await this.calculateAccuracy(context),
      timeUsing: await this.calculateTimeUsing(context),
      feedbackQuality: await this.calculateFeedbackQuality(context),
      errorRecovery: await this.calculateErrorRecovery(context)
    };
  }

  // FATOR 1: CONSISTÊNCIA (30%) - Padrões comportamentais estáveis
  private async calculateConsistency(context: TrustCalculationContext): Promise<number> {
    const { transactionHistory, userBehaviorPatterns } = context;

    // Analisar consistência em:
    // - Horários de transações (desvio padrão)
    // - Valores típicos (coeficiente de variação)
    // - Categorias frequentes (entropia)
    // - Padrões semanais/mensais (correlação)

    const timeConsistency = this.calculateTimePatternConsistency(transactionHistory);
    const amountConsistency = this.calculateAmountPatternConsistency(transactionHistory);
    const categoryConsistency = this.calculateCategoryConsistency(transactionHistory);
    const periodicConsistency = this.calculatePeriodicConsistency(transactionHistory);

    // Média ponderada dos sub-fatores
    return (
      timeConsistency * 0.25 +
      amountConsistency * 0.30 +
      categoryConsistency * 0.25 +
      periodicConsistency * 0.20
    );
  }

  // FATOR 2: PRECISÃO (25%) - Decisões aceitas vs rejeitadas
  private async calculateAccuracy(context: TrustCalculationContext): Promise<number> {
    const { feedbackHistory } = context;

    if (feedbackHistory.length === 0) return 0.5; // Score neutro para novos usuários

    // Calcular taxa de aceitação das decisões da IA
    const acceptedDecisions = feedbackHistory.filter(f =>
      f.rating >= 4 || f.action === 'accepted'
    ).length;

    const totalDecisions = feedbackHistory.length;
    const accuracyRate = acceptedDecisions / totalDecisions;

    // Aplicar curva de aprendizado (mais peso para feedback recente)
    const recentFeedback = feedbackHistory
      .filter(f => this.isRecentFeedback(f, 30)) // últimos 30 dias
      .slice(-20); // últimas 20 decisões

    if (recentFeedback.length > 0) {
      const recentAccuracy = recentFeedback.filter(f =>
        f.rating >= 4 || f.action === 'accepted'
      ).length / recentFeedback.length;

      // 70% peso para feedback recente, 30% para histórico
      return (recentAccuracy * 0.7) + (accuracyRate * 0.3);
    }

    return accuracyRate;
  }

  // FATOR 3: TEMPO DE USO (20%) - Experiência acumulada
  private async calculateTimeUsing(context: TrustCalculationContext): Promise<number> {
    const { userId } = context;

    // Buscar data de criação da conta
    const userCreatedAt = await this.getUserCreationDate(userId);
    const daysSinceCreation = this.daysBetween(userCreatedAt, new Date());

    // Buscar frequência de uso (dias ativos)
    const activeDays = await this.getActiveDaysCount(userId, daysSinceCreation);
    const usageFrequency = activeDays / daysSinceCreation;

    // Curva logarítmica para tempo (diminui retorno marginal)
    const timeScore = Math.min(1.0, Math.log10(daysSinceCreation + 1) / Math.log10(365)); // máximo 1 ano

    // Combinar tempo total com frequência de uso
    return (timeScore * 0.6) + (usageFrequency * 0.4);
  }

  // FATOR 4: QUALIDADE DO FEEDBACK (15%) - Engajamento e utilidade
  private async calculateFeedbackQuality(context: TrustCalculationContext): Promise<number> {
    const { feedbackHistory } = context;

    if (feedbackHistory.length === 0) return 0.3; // Score baixo para usuários sem feedback

    // Métricas de qualidade:
    // - Frequência de feedback (% de decisões com feedback)
    // - Detalhamento (feedback textual vs apenas rating)
    // - Consistência (feedback coerente ao longo do tempo)
    // - Utilidade (feedback que levou a melhorias)

    const feedbackFrequency = this.calculateFeedbackFrequency(context);
    const feedbackDetail = this.calculateFeedbackDetail(feedbackHistory);
    const feedbackConsistency = this.calculateFeedbackConsistency(feedbackHistory);
    const feedbackUtility = this.calculateFeedbackUtility(feedbackHistory);

    return (
      feedbackFrequency * 0.30 +
      feedbackDetail * 0.25 +
      feedbackConsistency * 0.25 +
      feedbackUtility * 0.20
    );
  }

  // FATOR 5: RECUPERAÇÃO DE ERROS (10%) - Resiliência
  private async calculateErrorRecovery(context: TrustCalculationContext): Promise<number> {
    const { errorHistory, transactionHistory } = context;

    if (errorHistory.length === 0) return 1.0; // Score máximo se não há erros

    // Analisar:
    // - Taxa de erros vs transações totais
    // - Tempo médio para resolução
    // - Capacidade de aprender com erros (não repetir)
    // - Colaboração na resolução (feedback útil)

    const errorRate = errorHistory.length / transactionHistory.length;
    const avgResolutionTime = this.calculateAverageResolutionTime(errorHistory);
    const errorLearning = this.calculateErrorLearningRate(errorHistory);
    const errorCollaboration = this.calculateErrorCollaboration(errorHistory);

    // Inverter taxa de erro (menos erros = melhor score)
    const errorRateScore = Math.max(0, 1 - (errorRate * 2));

    // Normalizar tempo de resolução (menos tempo = melhor)
    const resolutionScore = Math.max(0, 1 - (avgResolutionTime / (24 * 60))); // normalizar por 24h

    return (
      errorRateScore * 0.40 +
      resolutionScore * 0.30 +
      errorLearning * 0.20 +
      errorCollaboration * 0.10
    );
  }

  private applyWeights(factors: TrustFactors): number {
    return (
      factors.consistency * this.weights.consistency +
      factors.accuracy * this.weights.accuracy +
      factors.timeUsing * this.weights.timeUsing +
      factors.feedbackQuality * this.weights.feedbackQuality +
      factors.errorRecovery * this.weights.errorRecovery
    );
  }

  private determineAutonomyLevel(score: number): 50 | 75 | 95 {
    if (score >= 0.85) return 95; // Alta autonomia
    if (score >= 0.65) return 75; // Autonomia moderada
    return 50; // Autonomia básica
  }

  private calculateLimits(score: number, autonomyLevel: number): TrustLimits {
    // Limites baseados no score e nível de autonomia
    const baseDailyLimit = 1000; // R$ 1.000 base
    const baseTransactionLimit = 500; // R$ 500 base

    const multiplier = score * (autonomyLevel / 50); // Fator de multiplicação

    return {
      dailyLimit: Math.round(baseDailyLimit * multiplier),
      transactionLimit: Math.round(baseTransactionLimit * multiplier),
      monthlyLimit: Math.round(baseDailyLimit * multiplier * 20), // ~20 dias úteis
      categoryLimits: this.calculateCategoryLimits(score, autonomyLevel)
    };
  }
}

// Exemplo de cálculo de score
const exampleCalculation = {
  factors: {
    consistency: 0.82,      // 82% - Padrões comportamentais estáveis
    accuracy: 0.91,         // 91% - Alta taxa de aceitação das decisões
    timeUsing: 0.65,        // 65% - 6 meses de uso ativo
    feedbackQuality: 0.78,  // 78% - Feedback frequente e detalhado
    errorRecovery: 0.88     // 88% - Boa recuperação de erros
  },
  weights: {
    consistency: 0.30,
    accuracy: 0.25,
    timeUsing: 0.20,
    feedbackQuality: 0.15,
    errorRecovery: 0.10
  },
  calculation:
    (0.82 * 0.30) +  // 0.246
    (0.91 * 0.25) +  // 0.228
    (0.65 * 0.20) +  // 0.130
    (0.78 * 0.15) +  // 0.117
    (0.88 * 0.10),   // 0.088
  finalScore: 0.809,  // 80.9%
  autonomyLevel: 75,  // Autonomia moderada
  limits: {
    dailyLimit: 1618,      // R$ 1.618,00
    transactionLimit: 809, // R$ 809,00
    monthlyLimit: 32360    // R$ 32.360,00
  }
};
```

**Schema do Supabase:**
```sql
-- Tabela para scores de confiança
CREATE TABLE user_trust_scores (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) UNIQUE,
  
  -- Score atual
  current_score DECIMAL(5,2) NOT NULL CHECK (current_score >= 0 AND current_score <= 100),
  autonomy_level INTEGER NOT NULL CHECK (autonomy_level IN (50, 75, 95)),
  
  -- Fatores do score
  historical_consistency DECIMAL(5,2),
  transaction_patterns DECIMAL(5,2),
  feedback_quality DECIMAL(5,2),
  error_rate DECIMAL(5,2),
  usage_frequency DECIMAL(5,2),
  
  -- Metadados
  last_calculated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  calculation_version TEXT DEFAULT '1.0',
  
  -- Limites por nível
  daily_limit DECIMAL(10,2),
  transaction_limit DECIMAL(10,2),
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Tabela para histórico de scores
CREATE TABLE trust_score_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  score DECIMAL(5,2) NOT NULL,
  autonomy_level INTEGER NOT NULL,
  change_reason TEXT,
  factors JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Tabela para eventos que afetam confiança
CREATE TABLE trust_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  event_type TEXT NOT NULL CHECK (event_type IN ('positive', 'negative', 'neutral')),
  event_category TEXT NOT NULL,
  impact_score DECIMAL(3,2), -- -1.0 a +1.0
  description TEXT,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Tabela para recomendações
CREATE TABLE trust_recommendations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  recommendation_type TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  potential_impact DECIMAL(3,2),
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected', 'expired')),
  expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
```

### Algoritmo de Scoring

**Fatores de Confiança:**
```typescript
interface TrustFactors {
  historicalConsistency: number; // 0-100, baseado em padrões passados
  transactionPatterns: number;   // 0-100, regularidade de transações
  feedbackQuality: number;       // 0-100, qualidade do feedback dado
  errorRate: number;             // 0-100, inverso da taxa de erro
  usageFrequency: number;        // 0-100, frequência de uso do sistema
}

function calculateTrustScore(factors: TrustFactors): number {
  const weights = {
    historical: 0.3,
    patterns: 0.25,
    feedback: 0.2,
    errors: 0.15,
    usage: 0.1
  };
  
  return (
    factors.historicalConsistency * weights.historical +
    factors.transactionPatterns * weights.patterns +
    factors.feedbackQuality * weights.feedback +
    factors.errorRate * weights.errors +
    factors.usageFrequency * weights.usage
  );
}
```

### Testing

**Localização:** `src/test/ml/trust/`
**Frameworks:** Vitest + dados sintéticos
**Cenários de Teste:**
- Cálculo correto de scores com diferentes perfis
- Progressão de níveis de autonomia
- Degradação por erros e recuperação
- Performance com grandes volumes de dados
- Precisão de recomendações

**Validação de ML:**
- Cross-validation com dados históricos
- A/B testing de algoritmos
- Métricas de precisão e recall
- Análise de bias e fairness

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0.0 | Criação inicial da story | PM Agent "John" |
| 2025-10-04 | 1.1.0 | Refinamento pós-validação PO: Detalhado algoritmo de scoring com 5 fatores específicos e pesos (consistência 30%, precisão 25%, tempo 20%, feedback 15%, recuperação 10%), adicionados exemplos de cálculo | SM Agent |

---

## Dev Agent Record

*Esta seção será preenchida pelo agente de desenvolvimento durante a implementação*

---

## QA Results

*Esta seção será preenchida pelo agente de QA após revisão da implementação*