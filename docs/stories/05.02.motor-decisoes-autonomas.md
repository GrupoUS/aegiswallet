# Story 05.02: Motor de Decisões Autônomas

<!-- REFINAMENTO SM: Expandido Dev Notes, decomposição atômica de tasks, especificação técnica completa -->

## Status
**Current Status:** Draft
**Epic:** 05 - Autonomous Financial Intelligence
**Priority:** Future
**Estimated Effort:** 6 days
**Dependencies:** Smart Payment Automation, Voice Interface, Observability

---

## Story

**As a** usuário do AegisWallet,
**I want** que o sistema tome decisões financeiras inteligentes automaticamente baseadas no meu perfil e nível de confiança,
**so that** eu possa ter 95% das minhas tarefas financeiras gerenciadas sem intervenção manual, com total transparência.

---

## Acceptance Criteria

1. [ ] Configurar matriz de decisão considerando score, valor e categoria
2. [ ] Integrar com Automação de Pagamentos para disparar ações
3. [ ] Gerar justificativa textual com dados utilizados
4. [ ] Simular cenários (sandbox) antes do rollout
5. [ ] Monitorar impacto (tempo poupado, intervenções evitadas)
6. [ ] Precisão de decisões ≥90% em testes de validação
7. [ ] Tempo de decisão <1 segundo para respostas em tempo real
8. [ ] Taxa de intervenção manual <10% para usuários nível 95%

---

## Tasks / Subtasks

- [ ] **Configuração da Matriz de Decisão** (AC: 1, 6)
  - [ ] Criar arquivo `src/lib/ai/decisionMatrix.ts` com interface DecisionMatrix
  - [ ] Implementar função `calculateDecisionScore()` com 5 fatores ponderados
  - [ ] Configurar pesos por categoria: pagamentos (0.4), investimentos (0.3), alertas (0.3)
  - [ ] Adicionar validação de saldo mínimo (1.2x valor da transação)
  - [ ] Implementar histórico de padrões (últimos 90 dias de comportamento)
  - [ ] Configurar thresholds: baixo (<60), médio (60-80), alto (>80)
  - [ ] Criar testes unitários para cada cenário de decisão
  - [ ] Implementar logging detalhado de cada fator calculado

- [ ] **Algoritmo de Decisão Baseado em Regras** (AC: 1, 7)
  - [ ] Criar classe `DecisionEngine` em `src/lib/ai/decisionEngine.ts`
  - [ ] Implementar método `evaluatePaymentDecision()` com árvore de decisão
  - [ ] Adicionar método `evaluateAlertDecision()` para notificações proativas
  - [ ] Configurar método `evaluateInvestmentDecision()` para sugestões
  - [ ] Implementar cache Redis para decisões recentes (TTL: 5 minutos)
  - [ ] Adicionar rate limiting: máximo 100 decisões/minuto por usuário
  - [ ] Configurar timeout de 800ms para cálculos complexos
  - [ ] Implementar fallback para decisões manuais em caso de falha

- [ ] **Integração com Motor de Pagamentos** (AC: 2)
  - [ ] Conectar com `src/lib/payments/orchestrator.ts` via interface PaymentAction
  - [ ] Implementar método `triggerAutomaticPayment()` com validações
  - [ ] Adicionar integração com `executeScheduledPayment()` existente
  - [ ] Configurar webhook para notificar decisões tomadas
  - [ ] Implementar rollback automático para pagamentos falhados
  - [ ] Adicionar queue de decisões pendentes usando Supabase Edge Functions
  - [ ] Configurar retry logic: 3 tentativas com backoff exponencial
  - [ ] Implementar audit trail para todas as ações executadas

- [ ] **Sistema de Alertas Inteligentes** (AC: 2)
  - [ ] Integrar com `src/lib/notifications/alertManager.ts`
  - [ ] Implementar `generateProactiveAlert()` baseado em padrões
  - [ ] Configurar alertas de oportunidade (economia, investimento)
  - [ ] Adicionar alertas de risco (gastos excessivos, saldo baixo)
  - [ ] Implementar personalização de frequência por usuário
  - [ ] Configurar canais: push, email, voz (baseado em preferências)
  - [ ] Adicionar snooze inteligente (1h, 1d, 1w baseado no tipo)
  - [ ] Implementar feedback loop para melhorar relevância

- [ ] **Gerador de Justificativas** (AC: 3)
  - [ ] Criar `src/lib/ai/explanationGenerator.ts` com templates
  - [ ] Implementar método `generateExplanation()` com linguagem natural
  - [ ] Configurar templates por tipo: pagamento, alerta, bloqueio, sugestão
  - [ ] Adicionar referências específicas aos dados utilizados
  - [ ] Implementar níveis de detalhamento: básico (1 frase), detalhado (parágrafo)
  - [ ] Configurar tradução automática para português brasileiro
  - [ ] Adicionar personalização baseada no perfil do usuário
  - [ ] Implementar cache de explicações similares

- [ ] **Ambiente de Simulação (Sandbox)** (AC: 4)
  - [ ] Criar `src/lib/ai/simulationEngine.ts` para testes seguros
  - [ ] Implementar `runDecisionSimulation()` com dados históricos
  - [ ] Configurar cenários predefinidos: conservador, moderado, agressivo
  - [ ] Adicionar simulação de 30 dias de decisões automáticas
  - [ ] Implementar comparação com decisões manuais históricas
  - [ ] Configurar métricas de simulação: precisão, economia, satisfação
  - [ ] Adicionar relatório de simulação em formato PDF
  - [ ] Implementar aprovação manual antes de ativar automação

- [ ] **Dashboard de Monitoramento** (AC: 5, 8)
  - [ ] Criar `src/components/ai/DecisionMonitoringDashboard.tsx`
  - [ ] Implementar métricas em tempo real: decisões/hora, taxa de sucesso
  - [ ] Adicionar gráfico de tempo poupado por usuário (minutos/dia)
  - [ ] Configurar alertas para taxa de intervenção >15%
  - [ ] Implementar análise de tendências (semanal, mensal)
  - [ ] Adicionar comparação com baseline manual
  - [ ] Configurar exportação de relatórios para stakeholders
  - [ ] Implementar alertas automáticos para degradação de performance

---

## Dev Notes

### Arquitetura Relevante

**Estrutura Atual:**
- `src/lib/ml/trustScoring.ts` - Sistema de pontuação (Story 05.01)
- `src/lib/payments/orchestrator.ts` - Motor de pagamentos
- `src/server/procedures/` - APIs tRPC existentes

**Novos Arquivos Necessários:**
- `src/lib/ai/decisionEngine.ts` - Motor principal de decisões
- `src/lib/ai/decisionMatrix.ts` - Matriz de decisão
- `src/lib/ai/explanationGenerator.ts` - Gerador de explicações
- `src/lib/ai/simulationEngine.ts` - Engine de simulação
- `src/lib/ai/decisionMonitor.ts` - Monitor de decisões

### Especificação Técnica Detalhada

**Framework de Decisão:**
```typescript
// src/lib/ai/decisionEngine.ts
interface DecisionContext {
  userId: string;
  trustScore: number; // 0-100 from Story 05.01
  transactionAmount: number;
  category: TransactionCategory;
  accountBalance: number;
  historicalBehavior: UserBehaviorPattern;
  timeContext: {
    hour: number;
    dayOfWeek: number;
    isHoliday: boolean;
  };
}

interface DecisionResult {
  action: 'approve' | 'request_confirmation' | 'deny' | 'schedule';
  confidence: number; // 0-1
  reasoning: string[];
  dataUsed: string[];
  estimatedImpact: {
    timeSaved: number; // minutes
    riskLevel: number; // 0-1
    userSatisfaction: number; // predicted 0-1
  };
  executionPlan?: {
    when: Date;
    method: 'automatic' | 'voice_confirmation' | 'biometric';
    fallback: 'manual' | 'schedule' | 'cancel';
  };
}

class DecisionEngine {
  private matrix: DecisionMatrix;
  private explanationGenerator: ExplanationGenerator;

  constructor(
    private trustScoring: TrustScoringService,
    private paymentOrchestrator: PaymentOrchestrator
  ) {}

  async evaluateDecision(context: DecisionContext): Promise<DecisionResult> {
    // 1. Calculate decision score using weighted factors
    const score = await this.calculateDecisionScore(context);

    // 2. Apply business rules and thresholds
    const action = this.determineAction(score, context);

    // 3. Generate explanation
    const reasoning = await this.explanationGenerator.generate(context, action);

    // 4. Estimate impact
    const impact = this.estimateImpact(context, action);

    return {
      action,
      confidence: score.confidence,
      reasoning: reasoning.bullets,
      dataUsed: score.factorsUsed,
      estimatedImpact: impact,
      executionPlan: action !== 'deny' ? this.createExecutionPlan(context, action) : undefined
    };
  }

  private async calculateDecisionScore(context: DecisionContext): Promise<DecisionScore> {
    const factors = {
      trustFactor: context.trustScore / 100, // 0-1
      amountFactor: this.calculateAmountRisk(context.transactionAmount, context.accountBalance),
      behaviorFactor: this.analyzeBehaviorPattern(context.historicalBehavior, context.category),
      timingFactor: this.analyzeTimingPattern(context.timeContext, context.category),
      contextFactor: this.analyzeTransactionContext(context)
    };

    // Weighted calculation
    const weights = this.matrix.getWeights(context.category);
    const score = Object.entries(factors).reduce((sum, [key, value]) => {
      return sum + (value * weights[key as keyof typeof weights]);
    }, 0);

    return {
      score,
      confidence: this.calculateConfidence(factors),
      factorsUsed: Object.keys(factors),
      breakdown: factors
    };
  }
}
```

**Matriz de Decisão:**
```typescript
// src/lib/ai/decisionMatrix.ts
interface DecisionMatrix {
  categories: {
    [key in TransactionCategory]: {
      weights: FactorWeights;
      thresholds: DecisionThresholds;
      rules: BusinessRule[];
    };
  };
}

interface FactorWeights {
  trustFactor: number;      // 0.35 - Peso do score de confiança
  amountFactor: number;     // 0.25 - Peso do valor da transação
  behaviorFactor: number;   // 0.20 - Peso do padrão comportamental
  timingFactor: number;     // 0.15 - Peso do contexto temporal
  contextFactor: number;    // 0.05 - Peso de outros contextos
}

interface DecisionThresholds {
  autoApprove: number;      // >0.8 - Aprovação automática
  requestConfirmation: number; // 0.6-0.8 - Pedir confirmação
  deny: number;             // <0.6 - Negar automaticamente
}

const DEFAULT_MATRIX: DecisionMatrix = {
  categories: {
    bills: {
      weights: { trustFactor: 0.4, amountFactor: 0.2, behaviorFactor: 0.3, timingFactor: 0.1, contextFactor: 0.0 },
      thresholds: { autoApprove: 0.75, requestConfirmation: 0.5, deny: 0.3 },
      rules: [
        { condition: 'amount > monthlyIncome * 0.1', action: 'request_confirmation' },
        { condition: 'isRecurring && trustScore > 70', action: 'approve' }
      ]
    },
    transfers: {
      weights: { trustFactor: 0.5, amountFactor: 0.3, behaviorFactor: 0.15, timingFactor: 0.05, contextFactor: 0.0 },
      thresholds: { autoApprove: 0.85, requestConfirmation: 0.65, deny: 0.4 },
      rules: [
        { condition: 'amount > 1000', action: 'request_confirmation' },
        { condition: 'newRecipient && amount > 200', action: 'request_confirmation' }
      ]
    }
  }
};
```

**Schema do Supabase Expandido:**
```sql
-- Tabela para decisões automáticas (expandida)
CREATE TABLE autonomous_decisions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),

  -- Contexto da decisão
  decision_type TEXT NOT NULL CHECK (decision_type IN ('payment', 'categorization', 'alert', 'recommendation')),
  context_data JSONB NOT NULL,
  transaction_amount DECIMAL(12,2),
  transaction_category TEXT,

  -- Processo de decisão
  trust_score DECIMAL(5,2) NOT NULL,
  decision_factors JSONB NOT NULL, -- {trustFactor: 0.8, amountFactor: 0.6, ...}
  confidence_score DECIMAL(3,2) NOT NULL,
  matrix_version TEXT DEFAULT 'v1.0',

  -- Resultado
  decision TEXT NOT NULL CHECK (decision IN ('approve', 'request_confirmation', 'deny', 'schedule')),
  action_taken TEXT,
  execution_status TEXT CHECK (execution_status IN ('pending', 'executed', 'failed', 'cancelled', 'scheduled')),

  -- Justificativa
  explanation_text TEXT NOT NULL,
  explanation_data JSONB, -- {level: 'basic', dataUsed: [...], reasoning: [...]}

  -- Feedback e aprendizado
  user_feedback TEXT CHECK (user_feedback IN ('positive', 'negative', 'neutral')),
  manual_override BOOLEAN DEFAULT false,
  override_reason TEXT,
  satisfaction_score INTEGER CHECK (satisfaction_score >= 1 AND satisfaction_score <= 5),

  -- Performance e métricas
  processing_time_ms INTEGER,
  execution_time_ms INTEGER,
  time_saved_minutes INTEGER, -- Tempo estimado poupado

  -- Auditoria
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  executed_at TIMESTAMP WITH TIME ZONE,
  feedback_at TIMESTAMP WITH TIME ZONE,

  -- Índices para performance
  CONSTRAINT valid_confidence CHECK (confidence_score >= 0 AND confidence_score <= 1),
  CONSTRAINT valid_trust_score CHECK (trust_score >= 0 AND trust_score <= 100)
);

-- Índices otimizados
CREATE INDEX idx_autonomous_decisions_user_date ON autonomous_decisions(user_id, created_at DESC);
CREATE INDEX idx_autonomous_decisions_type_status ON autonomous_decisions(decision_type, execution_status);
CREATE INDEX idx_autonomous_decisions_feedback ON autonomous_decisions(user_feedback) WHERE user_feedback IS NOT NULL;

-- Tabela para matriz de decisão
CREATE TABLE decision_matrix_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  rule_name TEXT NOT NULL UNIQUE,
  decision_type TEXT NOT NULL,
  
  -- Condições
  conditions JSONB NOT NULL, -- {trust_score: ">= 80", amount: "< 1000", category: "bills"}
  
  -- Ação
  action TEXT NOT NULL,
  confidence_threshold DECIMAL(3,2) DEFAULT 0.8,
  
  -- Pesos e prioridade
  weight DECIMAL(3,2) DEFAULT 1.0,
  priority INTEGER DEFAULT 100,
  
  -- Status
  is_active BOOLEAN DEFAULT true,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Tabela para simulações
CREATE TABLE decision_simulations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  simulation_name TEXT NOT NULL,
  
  -- Configuração
  scenario_data JSONB NOT NULL,
  test_period_start DATE,
  test_period_end DATE,
  
  -- Resultados
  total_decisions INTEGER DEFAULT 0,
  correct_decisions INTEGER DEFAULT 0,
  accuracy_rate DECIMAL(5,2),
  
  -- Comparação com baseline
  baseline_accuracy DECIMAL(5,2),
  improvement_rate DECIMAL(5,2),
  
  -- Performance
  avg_processing_time_ms INTEGER,
  total_time_saved_minutes INTEGER,
  
  executed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  completed_at TIMESTAMP WITH TIME ZONE
);

-- Tabela para métricas de performance
CREATE TABLE decision_performance_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  metric_date DATE NOT NULL,
  
  -- Métricas de decisão
  total_decisions INTEGER DEFAULT 0,
  autonomous_decisions INTEGER DEFAULT 0,
  manual_overrides INTEGER DEFAULT 0,
  
  -- Métricas de tempo
  time_saved_minutes INTEGER DEFAULT 0,
  avg_decision_time_ms INTEGER,
  
  -- Métricas de qualidade
  accuracy_rate DECIMAL(5,2),
  user_satisfaction_score DECIMAL(3,2),
  
  -- Métricas financeiras
  automated_amount DECIMAL(12,2) DEFAULT 0,
  fees_saved DECIMAL(10,2) DEFAULT 0,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE(user_id, metric_date)
);
```

### Algoritmo de Decisão

**Fatores de Decisão:**
```typescript
interface DecisionContext {
  // Usuário
  trustScore: number;
  autonomyLevel: number;
  historicalBehavior: UserBehavior;
  
  // Transação/Ação
  amount: number;
  category: string;
  urgency: 'low' | 'medium' | 'high';
  riskLevel: number;
  
  // Contexto
  accountBalance: number;
  timeOfDay: string;
  dayOfWeek: string;
  recentActivity: RecentActivity[];
}

interface DecisionResult {
  action: 'execute' | 'request_approval' | 'block' | 'schedule';
  confidence: number;
  reasoning: string[];
  dataUsed: string[];
  estimatedImpact: {
    timeSaved: number;
    riskLevel: number;
    userSatisfaction: number;
  };
}
```

**Matriz de Decisão:**
```typescript
const decisionMatrix = {
  // Pagamentos automáticos
  payments: {
    conditions: {
      trustScore: '>= 80',
      amount: '<= userLimit',
      category: 'in [bills, utilities, subscriptions]',
      balance: '>= amount * 1.1'
    },
    action: 'execute',
    confidence: 0.9
  },
  
  // Alertas proativos
  alerts: {
    conditions: {
      trustScore: '>= 60',
      riskLevel: '>= 0.7',
      urgency: 'in [medium, high]'
    },
    action: 'notify',
    confidence: 0.8
  }
};
```

### Sistema de Explicações

**Templates de Explicação:**
```typescript
const explanationTemplates = {
  payment_executed: `Executei o pagamento de {description} no valor de {amount} porque:
    • Você tem um padrão regular de pagamento desta conta
    • Seu saldo atual ({balance}) é suficiente
    • Está dentro do seu limite configurado ({limit})
    • Seu nível de confiança ({trustScore}%) permite esta automação`,
    
  payment_blocked: `Bloqueei o pagamento de {description} porque:
    • O valor ({amount}) excede seu limite diário ({dailyLimit})
    • Não identifiquei um padrão regular para este beneficiário
    • Preciso de sua confirmação para valores acima de {threshold}`,
    
  alert_generated: `Enviei um alerta sobre {topic} porque:
    • Detectei uma oportunidade de economia de {savings}
    • Baseei-me no seu histórico dos últimos {months} meses
    • Esta ação pode impactar positivamente seu orçamento`
};
```

### Testing Detalhado

**Localização:** `src/test/ai/decisions/`
**Frameworks:** Vitest + MSW (mocking) + dados sintéticos

**Testes Unitários:**
```typescript
// src/test/ai/decisions/decisionEngine.test.ts
describe('DecisionEngine', () => {
  let engine: DecisionEngine;
  let mockTrustScoring: jest.Mocked<TrustScoringService>;

  beforeEach(() => {
    mockTrustScoring = createMockTrustScoring();
    engine = new DecisionEngine(mockTrustScoring, mockPaymentOrchestrator);
  });

  describe('evaluateDecision', () => {
    it('should approve low-risk recurring bill payment', async () => {
      const context = createTestContext({
        trustScore: 85,
        transactionAmount: 150,
        category: 'bills',
        isRecurring: true
      });

      const result = await engine.evaluateDecision(context);

      expect(result.action).toBe('approve');
      expect(result.confidence).toBeGreaterThan(0.8);
      expect(result.reasoning).toContain('pagamento recorrente');
    });

    it('should request confirmation for high-value transfer', async () => {
      const context = createTestContext({
        trustScore: 70,
        transactionAmount: 2000,
        category: 'transfers'
      });

      const result = await engine.evaluateDecision(context);

      expect(result.action).toBe('request_confirmation');
      expect(result.executionPlan?.method).toBe('voice_confirmation');
    });
  });
});
```

**Testes de Integração:**
```typescript
// src/test/ai/decisions/integration.test.ts
describe('Decision Engine Integration', () => {
  it('should execute approved payment through orchestrator', async () => {
    const mockOrchestrator = jest.mocked(paymentOrchestrator);
    const context = createApprovalContext();

    const result = await engine.evaluateDecision(context);
    await engine.executeDecision(result, context);

    expect(mockOrchestrator.executePayment).toHaveBeenCalledWith({
      amount: context.transactionAmount,
      recipient: context.recipient,
      method: 'automatic'
    });
  });
});
```

**Testes de Performance:**
```typescript
// src/test/ai/decisions/performance.test.ts
describe('Decision Engine Performance', () => {
  it('should process decision within 1 second', async () => {
    const start = Date.now();
    await engine.evaluateDecision(complexContext);
    const duration = Date.now() - start;

    expect(duration).toBeLessThan(1000);
  });

  it('should handle 100 concurrent decisions', async () => {
    const contexts = Array(100).fill(null).map(() => createRandomContext());
    const promises = contexts.map(ctx => engine.evaluateDecision(ctx));

    const results = await Promise.all(promises);
    expect(results).toHaveLength(100);
    expect(results.every(r => r.confidence > 0)).toBe(true);
  });
});
```

**Cenários de Teste Específicos:**
1. **Usuário Conservador** (Trust Score 50-60)
2. **Usuário Moderado** (Trust Score 70-80)
3. **Usuário Avançado** (Trust Score 90-95)
4. **Transações de Alto Valor** (>R$ 1.000)
5. **Horários Atípicos** (madrugada, feriados)
6. **Novos Beneficiários** (primeira transferência)
7. **Saldo Baixo** (<2x valor da transação)
8. **Falhas de Sistema** (timeout, API indisponível)

**Métricas de Qualidade Expandidas:**
- **Precisão de decisões**: ≥90% (medida contra decisões manuais históricas)
- **Tempo de processamento**: <1s (P95)
- **Taxa de satisfação**: ≥85% (pesquisa pós-decisão)
- **Taxa de override**: <10% (usuários nível 95%)
- **Disponibilidade**: 99.9% (SLA)
- **Falsos positivos**: <5% (aprovações incorretas)
- **Falsos negativos**: <3% (negações incorretas)

### Simulação e Validação

**Cenários de Teste:**
1. **Usuário Conservador**: Trust score 50-60%, decisões cautelosas
2. **Usuário Moderado**: Trust score 70-80%, automação balanceada
3. **Usuário Avançado**: Trust score 90-95%, máxima automação
4. **Cenários de Stress**: Múltiplas decisões simultâneas
5. **Cenários de Falha**: Dados incompletos ou inconsistentes

**Validação Contínua:**
- Comparação com decisões manuais históricas
- Análise de feedback do usuário
- Monitoramento de métricas de negócio
- Ajuste automático de parâmetros
- Rollback automático se performance degradar

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0.0 | Criação inicial da story | PM Agent "John" |

---

## Dev Agent Record

*Esta seção será preenchida pelo agente de desenvolvimento durante a implementação*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

---

## QA Results

*Esta seção será preenchida pelo agente de QA após revisão da implementação*