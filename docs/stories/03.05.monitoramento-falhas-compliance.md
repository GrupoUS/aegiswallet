# Story 03.05: Monitoramento, Falhas e Compliance

## Status
**Current Status:** Ready for Development
**Epic:** 03 - Smart Payment Automation
**Priority:** High
**Estimated Effort:** 3 days
**Dependencies:** Observability stack, Email/Slack notifications, Compliance team

---

## Story

**As a** responsável pela operação do AegisWallet,  
**I want** um sistema robusto de monitoramento que detecte falhas de pagamento, notifique usuários e mantenha compliance regulatório,  
**so that** possamos garantir confiabilidade operacional e conformidade com BACEN/LGPD em todos os pagamentos automatizados.

---

## Acceptance Criteria

1. [ ] Alertas em tempo real para falhas de pagamento ou atrasos
2. [ ] Integração com sistemas de ticket para suporte automático
3. [ ] Relatórios de conformidade BACEN/LGPD gerados mensalmente
4. [ ] Rotinas de failover em caso de indisponibilidade do provedor PIX
5. [ ] Testes de auditoria interna executados antes do lançamento
6. [ ] SLA de detecção de falhas <2 minutos
7. [ ] Taxa de recuperação automática ≥95% para falhas temporárias
8. [ ] Conformidade 100% com regulamentação de pagamentos instantâneos

---

## Tasks / Subtasks

- [ ] **Sistema de Alertas em Tempo Real** (AC: 1, 6)
  - [ ] Implementar detecção de falhas de pagamento em tempo real
  - [ ] Configurar alertas por Slack para equipe operacional
  - [ ] Adicionar notificações push para usuários afetados
  - [ ] Implementar escalation automático para falhas críticas
  - [ ] Configurar dashboard de status operacional

- [ ] **Sistema Simples de Alertas (MVP)** (AC: 2)
  - [ ] Configurar notificações por email usando Resend API
  - [ ] Implementar webhook Slack para alertas críticos
  - [ ] Criar templates básicos de alerta por severidade (low, medium, high, critical)
  - [ ] Adicionar contexto essencial: user_id, error_code, timestamp
  - [ ] Implementar rate limiting: máximo 1 alerta por tipo a cada 5 minutos
  - [ ] Configurar destinatários por tipo de alerta (dev team, ops team)

- [ ] **Relatórios de Conformidade** (AC: 3, 8)
  - [ ] Implementar geração automática de relatórios BACEN
  - [ ] Criar relatórios de conformidade LGPD mensais
  - [ ] Adicionar métricas de performance de pagamentos
  - [ ] Configurar auditoria de transações suspeitas
  - [ ] Implementar assinatura digital em relatórios críticos

- [ ] **Sistema de Failover e Resiliência** (AC: 4, 7)
  - [ ] Implementar failover automático entre provedores PIX
  - [ ] Configurar retry inteligente com backoff exponencial
  - [ ] Adicionar circuit breaker por provedor
  - [ ] Implementar queue de pagamentos para recuperação
  - [ ] Configurar monitoramento de saúde dos provedores

- [ ] **Auditoria e Testes de Compliance** (AC: 5)
  - [ ] Implementar testes automatizados de compliance
  - [ ] Criar checklist de auditoria interna
  - [ ] Configurar validação contínua de regulamentações
  - [ ] Implementar simulação de cenários de auditoria
  - [ ] Adicionar relatórios de preparação para auditoria

---

## Dev Notes

### Arquitetura Relevante

**Estrutura Atual:**
- `src/lib/payments/orchestrator.ts` - Motor de pagamentos
- `src/lib/banking/pixApi.ts` - API PIX
- `supabase/functions/` - Edge Functions para processamento

**Novos Arquivos Necessários:**
- `src/lib/monitoring/paymentMonitor.ts` - Monitor de pagamentos
- `src/lib/monitoring/alertManager.ts` - Gerenciador de alertas
- `src/lib/compliance/reportGenerator.ts` - Gerador de relatórios
- `src/lib/resilience/failoverManager.ts` - Gerenciador de failover
- `src/lib/audit/complianceChecker.ts` - Verificador de compliance
- `src/lib/notifications/emailNotifier.ts` - Notificações por email (Resend)
- `src/lib/notifications/slackNotifier.ts` - Notificações Slack

### Sistema Simples de Alertas (MVP)

**Princípio KISS:** Sistema básico de notificações sem complexidade de ticketing
**Justificativa:** MVP não precisa de sistema completo de tickets, apenas alertas para equipe

**Notificações por Email (Resend API):**
- **Escolha**: Resend já integrado no projeto, API simples
- **Endpoint**: `https://api.resend.com/emails`
- **Autenticação**: API Key em variável de ambiente `RESEND_API_KEY`
- **Rate Limit**: 100 emails/hora (suficiente para MVP)

**Notificações Slack (Webhook):**
- **Escolha**: Webhook simples, sem SDK adicional
- **Endpoint**: `https://hooks.slack.com/services/[workspace]/[channel]/[token]`
- **Configuração**: URL do webhook em `SLACK_WEBHOOK_URL`
- **Rate Limit**: 1 mensagem/segundo

**Implementação Simplificada:**
```typescript
// src/lib/notifications/emailNotifier.ts
import { Resend } from 'resend';

interface AlertContext {
  userId?: string;
  errorCode: string;
  errorMessage: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: 'pix' | 'boleto' | 'banking' | 'system';
  timestamp: Date;
}

class EmailNotifier {
  private resend: Resend;
  private recipients: Record<string, string[]> = {
    critical: ['dev-team@aegiswallet.com', 'ops@aegiswallet.com'],
    high: ['dev-team@aegiswallet.com'],
    medium: ['dev-team@aegiswallet.com'],
    low: ['ops@aegiswallet.com']
  };

  constructor(apiKey: string) {
    this.resend = new Resend(apiKey);
  }

  async sendAlert(context: AlertContext): Promise<void> {
    const recipients = this.recipients[context.severity];
    const subject = this.generateSubject(context);
    const html = this.generateEmailHTML(context);

    await this.resend.emails.send({
      from: 'alerts@aegiswallet.com',
      to: recipients,
      subject,
      html
    });
  }

  private generateSubject(context: AlertContext): string {
    return `[${context.severity.toUpperCase()}] ${context.category.toUpperCase()}: ${context.errorCode}`;
  }

  private generateEmailHTML(context: AlertContext): string {
    return `
      <h2>Alerta AegisWallet - ${context.severity.toUpperCase()}</h2>
      <p><strong>Categoria:</strong> ${context.category}</p>
      <p><strong>Código:</strong> ${context.errorCode}</p>
      <p><strong>Mensagem:</strong> ${context.errorMessage}</p>
      <p><strong>Timestamp:</strong> ${context.timestamp.toISOString()}</p>
      ${context.userId ? `<p><strong>User ID:</strong> ${context.userId}</p>` : ''}
      <hr>
      <p><a href="https://app.aegiswallet.com/admin/monitoring">Ver Dashboard</a></p>
    `;
  }
}

// src/lib/notifications/slackNotifier.ts
class SlackNotifier {
  private webhookUrl: string;
  private lastAlertTime: Map<string, number> = new Map();
  private rateLimitMs = 300000; // 5 minutos

  constructor(webhookUrl: string) {
    this.webhookUrl = webhookUrl;
  }

  async sendAlert(context: AlertContext): Promise<void> {
    // Rate limiting: 1 alerta por tipo a cada 5 minutos
    const alertKey = `${context.category}-${context.errorCode}`;
    const lastTime = this.lastAlertTime.get(alertKey) || 0;
    const now = Date.now();

    if (now - lastTime < this.rateLimitMs) {
      console.log(`Rate limit: Skipping duplicate alert for ${alertKey}`);
      return;
    }

    const payload = this.generateSlackPayload(context);

    await fetch(this.webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    this.lastAlertTime.set(alertKey, now);
  }

  private generateSlackPayload(context: AlertContext) {
    const emoji = {
      critical: ':rotating_light:',
      high: ':warning:',
      medium: ':large_orange_diamond:',
      low: ':information_source:'
    }[context.severity];

    return {
      text: `${emoji} *${context.severity.toUpperCase()}* - ${context.category.toUpperCase()}`,
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: `${emoji} Alerta ${context.severity.toUpperCase()}`
          }
        },
        {
          type: 'section',
          fields: [
            { type: 'mrkdwn', text: `*Categoria:*\n${context.category}` },
            { type: 'mrkdwn', text: `*Código:*\n${context.errorCode}` },
            { type: 'mrkdwn', text: `*Mensagem:*\n${context.errorMessage}` },
            { type: 'mrkdwn', text: `*Timestamp:*\n${context.timestamp.toISOString()}` }
          ]
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: { type: 'plain_text', text: 'Ver Dashboard' },
              url: 'https://app.aegiswallet.com/admin/monitoring'
            }
          ]
        }
      ]
    };
  }
}

// src/lib/monitoring/alertManager.ts (Simplificado para MVP)
class AlertManager {
  private emailNotifier: EmailNotifier;
  private slackNotifier: SlackNotifier;

  constructor(emailNotifier: EmailNotifier, slackNotifier: SlackNotifier) {
    this.emailNotifier = emailNotifier;
    this.slackNotifier = slackNotifier;
  }

  async sendAlert(context: AlertContext): Promise<void> {
    // Enviar para ambos os canais em paralelo
    await Promise.all([
      this.emailNotifier.sendAlert(context),
      this.slackNotifier.sendAlert(context)
    ]);

    // Log no Supabase para auditoria
    await this.logAlert(context);
  }

  private async logAlert(context: AlertContext): Promise<void> {
    await supabase.from('alert_logs').insert({
      error_code: context.errorCode,
      error_message: context.errorMessage,
      severity: context.severity,
      category: context.category,
      user_id: context.userId,
      created_at: context.timestamp.toISOString()
    });
  }
}
```

**Schema Simplificado do Supabase:**
```sql
-- Tabela para logs de alertas (MVP)
CREATE TABLE alert_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  error_code TEXT NOT NULL,
  error_message TEXT NOT NULL,
  severity TEXT NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
  category TEXT NOT NULL CHECK (category IN ('pix', 'boleto', 'banking', 'system')),
  user_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Tabela para relatórios de compliance
CREATE TABLE compliance_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  report_type TEXT NOT NULL CHECK (report_type IN ('bacen_monthly', 'lgpd_quarterly', 'audit_annual')),
  report_period_start DATE NOT NULL,
  report_period_end DATE NOT NULL,
  
  -- Métricas do relatório
  total_transactions INTEGER,
  successful_transactions INTEGER,
  failed_transactions INTEGER,
  average_processing_time_ms INTEGER,
  
  -- Compliance metrics
  compliance_score DECIMAL(3,2),
  violations_found INTEGER DEFAULT 0,
  violations_resolved INTEGER DEFAULT 0,
  
  -- Arquivo do relatório
  report_file_path TEXT,
  digital_signature TEXT,
  
  -- Status
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'review', 'approved', 'submitted')),
  approved_by TEXT,
  submitted_at TIMESTAMP WITH TIME ZONE,
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Tabela para failover de provedores
CREATE TABLE provider_failover_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  primary_provider TEXT NOT NULL,
  fallback_provider TEXT NOT NULL,
  
  -- Motivo do failover
  trigger_reason TEXT NOT NULL,
  error_details JSONB,
  
  -- Métricas do failover
  failover_time_ms INTEGER,
  affected_payments INTEGER,
  recovery_time_ms INTEGER,
  
  -- Status
  status TEXT NOT NULL CHECK (status IN ('initiated', 'completed', 'failed', 'reverted')),
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  completed_at TIMESTAMP WITH TIME ZONE
);

-- Tabela para testes de auditoria
CREATE TABLE audit_test_results (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  test_name TEXT NOT NULL,
  test_category TEXT NOT NULL,
  
  -- Resultado do teste
  status TEXT NOT NULL CHECK (status IN ('passed', 'failed', 'warning', 'skipped')),
  score DECIMAL(3,2),
  
  -- Detalhes
  test_details JSONB,
  findings TEXT[],
  recommendations TEXT[],
  
  -- Execução
  executed_by TEXT,
  execution_time_ms INTEGER,
  executed_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
```

### Sistema de Monitoramento

**Métricas Principais:**
- Taxa de sucesso de pagamentos por provedor
- Tempo médio de processamento
- Taxa de retry e recuperação
- Disponibilidade dos provedores PIX
- Conformidade com SLAs regulatórios

**Alertas Configurados:**
- Taxa de falha >5% em 10 minutos → Slack Critical
- Provedor PIX indisponível >2 minutos → PagerDuty
- Pagamento crítico falhando >3 tentativas → Email + Ticket
- Violação de compliance detectada → Escalation imediata

### Compliance e Regulamentação

**BACEN - Regulamentação PIX:**
- Tempo máximo de processamento: 10 segundos
- Disponibilidade mínima: 99,9%
- Logs de auditoria: 5 anos
- Relatórios mensais obrigatórios

**LGPD - Proteção de Dados:**
- Consentimento para processamento
- Minimização de dados coletados
- Direito ao esquecimento
- Notificação de incidentes em 72h

### Sistema de Failover

**Estratégia Multi-provedor:**
1. **Provedor Primário**: OpenPix (ou equivalente)
2. **Provedor Secundário**: Integração bancária direta
3. **Provedor Terciário**: Queue para processamento manual

**Critérios de Failover:**
- Taxa de erro >20% em 5 minutos
- Latência >10 segundos consistente
- Indisponibilidade total >1 minuto
- Falhas de autenticação recorrentes

### Testing

**Localização:** `src/test/monitoring/payments/`
**Frameworks:** Vitest + simulação de falhas
**Cenários de Teste:**
- Simulação de falha de provedor PIX
- Teste de alertas e escalation
- Validação de relatórios de compliance
- Teste de failover automático
- Auditoria de logs de segurança

**Testes de Caos:**
- Indisponibilidade de provedor principal
- Falhas de rede intermitentes
- Sobrecarga de transações
- Falhas de autenticação
- Corrupção de dados

**Métricas de Qualidade:**
- Detecção de falhas <2 minutos
- Recuperação automática ≥95%
- Conformidade regulatória 100%
- SLA de resolução <15 minutos

### Relatórios Automatizados

**Relatório Mensal BACEN:**
- Volume de transações PIX
- Taxa de sucesso por tipo
- Tempo médio de processamento
- Incidentes e resoluções
- Métricas de disponibilidade

**Relatório Trimestral LGPD:**
- Dados pessoais processados
- Consentimentos coletados/revogados
- Incidentes de segurança
- Exercício de direitos dos titulares
- Medidas de proteção implementadas

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0.0 | Criação inicial da story | PM Agent "John" |
| 2025-10-04 | 1.1.0 | Refinamento pós-validação PO: Especificado Zendesk como sistema de tickets, adicionadas APIs de integração e templates de criação automática | SM Agent |
| 2025-10-04 | 1.2.0 | Simplificação para MVP: Removido Zendesk (over-engineering), substituído por sistema simples de alertas (Resend email + Slack webhook) seguindo princípios KISS/YAGNI | SM Agent |

---

## Dev Agent Record

*Esta seção será preenchida pelo agente de desenvolvimento durante a implementação*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

---

## QA Results

*Esta seção será preenchida pelo agente de QA após revisão da implementação*