# Story 02.01: Configuração de Conectores Open Banking

## Status
**Current Status:** Approved
**Epic:** 02 - Banking Integration Core  
**Priority:** Critical  
**Estimated Effort:** 4 days  
**Dependencies:** Integração Belvo, Supabase Functions, Auth Context

---

## Story

**As a** usuário do AegisWallet,  
**I want** conectar minhas contas dos principais bancos brasileiros de forma segura e auditável,  
**so that** eu possa ter uma visão consolidada das minhas finanças e permitir automação inteligente dos meus pagamentos.

---

## Acceptance Criteria

1. [ ] Conectar Bradesco, Itaú, Banco do Brasil, Caixa e Nubank com status monitorável
2. [ ] Persistir tokens criptografados utilizando Supabase secrets
3. [ ] Implementar renovação automática de consentimento com notificações ao usuário
4. [ ] Registrar trilha de auditoria (quem conectou, quando, escopo de dados)
5. [ ] Testes automatizados cobrindo falhas de autenticação e consentimento negado
6. [ ] Taxa de sucesso de conexão ≥95% por instituição
7. [ ] Tempo de estabelecimento de conexão <30 segundos
8. [ ] Conformidade total com regulamentação Open Banking Brasil

---

## Tasks / Subtasks

- [ ] **Configuração da Integração Belvo** (AC: 1)
  - [ ] Configurar credenciais Belvo no ambiente de desenvolvimento
  - [ ] Implementar cliente Belvo com as 5 instituições prioritárias
  - [ ] Criar mapeamento de instituições para códigos Belvo
  - [ ] Implementar health check para status de cada conector
  - [ ] Adicionar retry logic para falhas temporárias de conexão

- [ ] **Sistema de Gerenciamento de Tokens** (AC: 2)
  - [ ] Implementar criptografia AES-256 para tokens de acesso
  - [ ] Configurar Supabase Vault para armazenamento seguro
  - [ ] Criar rotação automática de chaves de criptografia
  - [ ] Implementar isolamento de tokens por usuário (RLS)
  - [ ] Adicionar logs de acesso aos tokens para auditoria

- [ ] **Fluxo de Consentimento e Renovação** (AC: 3)
  - [ ] Implementar fluxo OAuth2 completo para cada banco
  - [ ] Criar sistema de notificação 7 dias antes do vencimento
  - [ ] Implementar renovação automática quando possível
  - [ ] Adicionar interface para re-autorização manual
  - [ ] Configurar webhooks para mudanças de status de consentimento

- [ ] **Sistema de Auditoria** (AC: 4)
  - [ ] Criar tabela de logs de conexão no Supabase
  - [ ] Implementar logging estruturado com metadados completos
  - [ ] Adicionar assinatura digital nos logs críticos
  - [ ] Criar dashboard interno para monitoramento de conexões
  - [ ] Implementar alertas para atividades suspeitas

- [ ] **Testes e Validação** (AC: 5, 6, 7, 8)
  - [ ] Criar suite de testes para cada instituição bancária
  - [ ] Implementar testes de falha e recuperação
  - [ ] Adicionar testes de performance e timeout
  - [ ] Validar conformidade com padrões Open Banking Brasil
  - [ ] Criar testes de carga para múltiplas conexões simultâneas

---

## Dev Notes

### Arquitetura Relevante

**Estrutura Atual:**
- `src/lib/banking/belvoApi.ts` - Cliente Belvo (stub implementado)
- `src/integrations/supabase/client.ts` - Cliente Supabase configurado
- `src/server/context.ts` - Contexto de autenticação tRPC

**Novos Arquivos Necessários:**
- `src/lib/banking/bankConnectors.ts` - Gerenciador de conectores
- `src/lib/banking/tokenManager.ts` - Gerenciamento seguro de tokens
- `src/lib/banking/auditLogger.ts` - Sistema de auditoria
- `src/lib/banking/errorHandler.ts` - Tratamento de erros específicos por banco
- `src/server/procedures/banking.ts` - Procedures tRPC para banking

### Error Codes Específicos por Banco

**Códigos de Erro Padronizados:**
```typescript
// src/lib/banking/errorHandler.ts
enum BankingErrorCode {
  // Erros de Conectividade
  NETWORK_TIMEOUT = 'NETWORK_TIMEOUT',
  CONNECTION_REFUSED = 'CONNECTION_REFUSED',
  DNS_RESOLUTION_FAILED = 'DNS_RESOLUTION_FAILED',

  // Erros de Autenticação
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  CONSENT_REVOKED = 'CONSENT_REVOKED',
  MFA_REQUIRED = 'MFA_REQUIRED',
  ACCOUNT_LOCKED = 'ACCOUNT_LOCKED',

  // Erros de Rate Limiting
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  DAILY_LIMIT_REACHED = 'DAILY_LIMIT_REACHED',
  CONCURRENT_LIMIT_EXCEEDED = 'CONCURRENT_LIMIT_EXCEEDED',

  // Erros de Dados
  ACCOUNT_NOT_FOUND = 'ACCOUNT_NOT_FOUND',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
  DATA_UNAVAILABLE = 'DATA_UNAVAILABLE',
  INVALID_DATE_RANGE = 'INVALID_DATE_RANGE',

  // Erros do Banco
  BANK_MAINTENANCE = 'BANK_MAINTENANCE',
  BANK_SYSTEM_ERROR = 'BANK_SYSTEM_ERROR',
  BANK_TIMEOUT = 'BANK_TIMEOUT',

  // Erros da Belvo
  BELVO_API_ERROR = 'BELVO_API_ERROR',
  BELVO_RATE_LIMIT = 'BELVO_RATE_LIMIT',
  BELVO_MAINTENANCE = 'BELVO_MAINTENANCE'
}

interface BankErrorMapping {
  [bankCode: string]: {
    [originalError: string]: {
      code: BankingErrorCode;
      userMessage: string;
      retryStrategy: RetryStrategy;
      severity: 'low' | 'medium' | 'high' | 'critical';
    };
  };
}

const BANK_ERROR_MAPPINGS: BankErrorMapping = {
  // Itaú
  'itau': {
    'CONN_TIMEOUT': {
      code: BankingErrorCode.NETWORK_TIMEOUT,
      userMessage: 'Conexão com o Itaú demorou mais que o esperado. Tentando novamente...',
      retryStrategy: { maxRetries: 3, backoffMs: 2000, exponential: true },
      severity: 'medium'
    },
    'AUTH_FAILED': {
      code: BankingErrorCode.INVALID_CREDENTIALS,
      userMessage: 'Credenciais do Itaú inválidas. Verifique seus dados de acesso.',
      retryStrategy: { maxRetries: 0, backoffMs: 0, exponential: false },
      severity: 'high'
    },
    'RATE_LIMIT': {
      code: BankingErrorCode.RATE_LIMIT_EXCEEDED,
      userMessage: 'Muitas tentativas no Itaú. Aguarde 5 minutos antes de tentar novamente.',
      retryStrategy: { maxRetries: 1, backoffMs: 300000, exponential: false }, // 5 min
      severity: 'medium'
    }
  },

  // Bradesco
  'bradesco': {
    'SYSTEM_UNAVAILABLE': {
      code: BankingErrorCode.BANK_MAINTENANCE,
      userMessage: 'Sistema do Bradesco em manutenção. Tentaremos novamente em alguns minutos.',
      retryStrategy: { maxRetries: 5, backoffMs: 60000, exponential: true }, // 1 min base
      severity: 'medium'
    },
    'TOKEN_INVALID': {
      code: BankingErrorCode.TOKEN_EXPIRED,
      userMessage: 'Acesso ao Bradesco expirou. Reconectando automaticamente...',
      retryStrategy: { maxRetries: 1, backoffMs: 1000, exponential: false },
      severity: 'low'
    }
  },

  // Banco do Brasil
  'bb': {
    'MFA_CHALLENGE': {
      code: BankingErrorCode.MFA_REQUIRED,
      userMessage: 'Banco do Brasil requer autenticação adicional. Verifique seu celular.',
      retryStrategy: { maxRetries: 0, backoffMs: 0, exponential: false },
      severity: 'high'
    },
    'CONCURRENT_ACCESS': {
      code: BankingErrorCode.CONCURRENT_LIMIT_EXCEEDED,
      userMessage: 'Você já está conectado ao BB em outro dispositivo. Desconecte e tente novamente.',
      retryStrategy: { maxRetries: 2, backoffMs: 30000, exponential: false }, // 30s
      severity: 'medium'
    }
  },

  // Santander
  'santander': {
    'ACCOUNT_BLOCKED': {
      code: BankingErrorCode.ACCOUNT_LOCKED,
      userMessage: 'Conta Santander temporariamente bloqueada. Entre em contato com o banco.',
      retryStrategy: { maxRetries: 0, backoffMs: 0, exponential: false },
      severity: 'critical'
    },
    'DATA_NOT_AVAILABLE': {
      code: BankingErrorCode.DATA_UNAVAILABLE,
      userMessage: 'Dados não disponíveis no Santander no momento. Tentando novamente...',
      retryStrategy: { maxRetries: 3, backoffMs: 5000, exponential: true },
      severity: 'low'
    }
  },

  // Caixa
  'caixa': {
    'MAINTENANCE_WINDOW': {
      code: BankingErrorCode.BANK_MAINTENANCE,
      userMessage: 'Caixa em manutenção programada (22h-6h). Dados serão atualizados pela manhã.',
      retryStrategy: { maxRetries: 1, backoffMs: 28800000, exponential: false }, // 8h
      severity: 'low'
    },
    'SLOW_RESPONSE': {
      code: BankingErrorCode.BANK_TIMEOUT,
      userMessage: 'Sistema da Caixa lento. Aguarde, estamos processando...',
      retryStrategy: { maxRetries: 2, backoffMs: 10000, exponential: true },
      severity: 'medium'
    }
  }
};

interface RetryStrategy {
  maxRetries: number;
  backoffMs: number;
  exponential: boolean;
}

class BankingErrorHandler {
  private errorMappings: BankErrorMapping;

  constructor() {
    this.errorMappings = BANK_ERROR_MAPPINGS;
  }

  handleBankError(bankCode: string, originalError: string, context: ErrorContext): BankingError {
    // 1. Mapear erro específico do banco
    const bankMapping = this.errorMappings[bankCode];
    const errorMapping = bankMapping?.[originalError];

    if (errorMapping) {
      return {
        code: errorMapping.code,
        message: errorMapping.userMessage,
        originalError,
        bankCode,
        retryStrategy: errorMapping.retryStrategy,
        severity: errorMapping.severity,
        context,
        timestamp: new Date(),
        canRetry: errorMapping.retryStrategy.maxRetries > 0
      };
    }

    // 2. Fallback para erro genérico
    return this.createGenericError(bankCode, originalError, context);
  }

  async executeWithRetry<T>(
    operation: () => Promise<T>,
    retryStrategy: RetryStrategy,
    errorHandler: (error: any, attempt: number) => boolean = () => true
  ): Promise<T> {
    let lastError: any;

    for (let attempt = 0; attempt <= retryStrategy.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;

        // Verificar se deve tentar novamente
        if (attempt === retryStrategy.maxRetries || !errorHandler(error, attempt)) {
          break;
        }

        // Calcular delay
        const delay = retryStrategy.exponential
          ? retryStrategy.backoffMs * Math.pow(2, attempt)
          : retryStrategy.backoffMs;

        console.log(`Tentativa ${attempt + 1} falhou. Tentando novamente em ${delay}ms...`);
        await this.sleep(delay);
      }
    }

    throw lastError;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Exemplo de uso
const errorHandler = new BankingErrorHandler();

try {
  const accounts = await errorHandler.executeWithRetry(
    () => belvoClient.getAccounts(institutionId),
    { maxRetries: 3, backoffMs: 2000, exponential: true },
    (error, attempt) => {
      // Só retry em erros temporários
      return error.code !== BankingErrorCode.INVALID_CREDENTIALS;
    }
  );
} catch (error) {
  const bankingError = errorHandler.handleBankError('itau', error.message, {
    userId,
    institutionId,
    operation: 'getAccounts'
  });

  // Mostrar mensagem amigável para o usuário
  toast.error(bankingError.message);

  // Log técnico para debugging
  console.error('Banking operation failed:', bankingError);
}
```

### Estratégias de Retry por Tipo de Erro

**Configuração de Retry Inteligente:**
```typescript
// src/lib/banking/retryStrategies.ts
const RETRY_STRATEGIES = {
  // Erros temporários - retry agressivo
  [BankingErrorCode.NETWORK_TIMEOUT]: {
    maxRetries: 3,
    backoffMs: 1000,
    exponential: true,
    jitter: true // Adiciona aleatoriedade para evitar thundering herd
  },

  // Rate limiting - retry com delay longo
  [BankingErrorCode.RATE_LIMIT_EXCEEDED]: {
    maxRetries: 2,
    backoffMs: 60000, // 1 minuto
    exponential: false,
    jitter: false
  },

  // Manutenção do banco - retry com delay muito longo
  [BankingErrorCode.BANK_MAINTENANCE]: {
    maxRetries: 1,
    backoffMs: 1800000, // 30 minutos
    exponential: false,
    jitter: true
  },

  // Erros de autenticação - não retry
  [BankingErrorCode.INVALID_CREDENTIALS]: {
    maxRetries: 0,
    backoffMs: 0,
    exponential: false,
    jitter: false
  },

  // Token expirado - retry imediato após refresh
  [BankingErrorCode.TOKEN_EXPIRED]: {
    maxRetries: 1,
    backoffMs: 500,
    exponential: false,
    jitter: false
  }
};
```

### Mensagens de Erro para Usuário

**Templates de Mensagem por Contexto:**
```typescript
const USER_ERROR_MESSAGES = {
  [BankingErrorCode.NETWORK_TIMEOUT]: {
    title: 'Conexão Lenta',
    message: 'A conexão com seu banco está mais lenta que o normal. Estamos tentando novamente...',
    action: 'Aguarde alguns segundos',
    icon: '⏳'
  },

  [BankingErrorCode.INVALID_CREDENTIALS]: {
    title: 'Dados de Acesso Inválidos',
    message: 'Não conseguimos acessar sua conta bancária. Verifique se seus dados estão corretos.',
    action: 'Reconectar Banco',
    icon: '🔐'
  },

  [BankingErrorCode.BANK_MAINTENANCE]: {
    title: 'Banco em Manutenção',
    message: 'Seu banco está em manutenção programada. Seus dados serão atualizados assim que possível.',
    action: 'Tentar Mais Tarde',
    icon: '🔧'
  },

  [BankingErrorCode.RATE_LIMIT_EXCEEDED]: {
    title: 'Muitas Tentativas',
    message: 'Fizemos muitas consultas ao seu banco recentemente. Aguarde alguns minutos.',
    action: 'Aguardar 5 minutos',
    icon: '⏱️'
  }
};
```

**Schema do Supabase:**
```sql
-- Tabela para conexões bancárias
CREATE TABLE bank_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  institution_id TEXT NOT NULL,
  institution_name TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('active', 'expired', 'revoked', 'error')),
  consent_expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Tabela para logs de auditoria
CREATE TABLE banking_audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  action TEXT NOT NULL,
  institution_id TEXT,
  metadata JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
```

### Configurações de Segurança

**Variáveis de Ambiente Necessárias:**
- `BELVO_API_KEY` - Chave da API Belvo
- `BELVO_SECRET_KEY` - Chave secreta Belvo
- `BANKING_ENCRYPTION_KEY` - Chave para criptografia de tokens
- `OPEN_BANKING_WEBHOOK_SECRET` - Secret para validação de webhooks

**Políticas RLS:**
- Usuários só podem ver suas próprias conexões bancárias
- Logs de auditoria isolados por usuário
- Tokens criptografados nunca expostos via API

### Testing

**Localização:** `src/test/banking/connectors/`
**Frameworks:** Vitest para lógica, Playwright para fluxos OAuth
**Ambientes de Teste:**
- Sandbox Belvo para testes automatizados
- Mock servers para testes de falha
- Ambiente de homologação com bancos reais

**Cenários de Teste Críticos:**
- Conexão bem-sucedida com cada banco
- Falha de autenticação e recuperação
- Expiração de token e renovação
- Revogação de consentimento pelo usuário
- Indisponibilidade temporária do banco

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0.0 | Criação inicial da story | PM Agent "John" |
| 2025-10-04 | 1.1.0 | Refinamento pós-validação PO: Adicionados error codes específicos por banco (Itaú, Bradesco, BB, Santander, Caixa), estratégias de retry inteligente por tipo de erro, mensagens de usuário contextuais | SM Agent |

---

## Dev Agent Record

*Esta seção será preenchida pelo agente de desenvolvimento durante a implementação*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

---

## QA Results

*Esta seção será preenchida pelo agente de QA após revisão da implementação*