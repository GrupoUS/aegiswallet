# Story 02.01: Configura√ß√£o de Conectores Open Banking

## Status
**Current Status:** Approved
**Epic:** 02 - Banking Integration Core  
**Priority:** Critical  
**Estimated Effort:** 4 days  
**Dependencies:** Integra√ß√£o Belvo, Supabase Functions, Auth Context

---

## Story

**As a** usu√°rio do AegisWallet,  
**I want** conectar minhas contas dos principais bancos brasileiros de forma segura e audit√°vel,  
**so that** eu possa ter uma vis√£o consolidada das minhas finan√ßas e permitir automa√ß√£o inteligente dos meus pagamentos.

---

## Acceptance Criteria

1. [ ] Conectar Bradesco, Ita√∫, Banco do Brasil, Caixa e Nubank com status monitor√°vel
2. [ ] Persistir tokens criptografados utilizando Supabase secrets
3. [ ] Implementar renova√ß√£o autom√°tica de consentimento com notifica√ß√µes ao usu√°rio
4. [ ] Registrar trilha de auditoria (quem conectou, quando, escopo de dados)
5. [ ] Testes automatizados cobrindo falhas de autentica√ß√£o e consentimento negado
6. [ ] Taxa de sucesso de conex√£o ‚â•95% por institui√ß√£o
7. [ ] Tempo de estabelecimento de conex√£o <30 segundos
8. [ ] Conformidade total com regulamenta√ß√£o Open Banking Brasil

---

## Tasks / Subtasks

- [ ] **Configura√ß√£o da Integra√ß√£o Belvo** (AC: 1)
  - [ ] Configurar credenciais Belvo no ambiente de desenvolvimento
  - [ ] Implementar cliente Belvo com as 5 institui√ß√µes priorit√°rias
  - [ ] Criar mapeamento de institui√ß√µes para c√≥digos Belvo
  - [ ] Implementar health check para status de cada conector
  - [ ] Adicionar retry logic para falhas tempor√°rias de conex√£o

- [ ] **Sistema de Gerenciamento de Tokens** (AC: 2)
  - [ ] Implementar criptografia AES-256 para tokens de acesso
  - [ ] Configurar Supabase Vault para armazenamento seguro
  - [ ] Criar rota√ß√£o autom√°tica de chaves de criptografia
  - [ ] Implementar isolamento de tokens por usu√°rio (RLS)
  - [ ] Adicionar logs de acesso aos tokens para auditoria

- [ ] **Fluxo de Consentimento e Renova√ß√£o** (AC: 3)
  - [ ] Implementar fluxo OAuth2 completo para cada banco
  - [ ] Criar sistema de notifica√ß√£o 7 dias antes do vencimento
  - [ ] Implementar renova√ß√£o autom√°tica quando poss√≠vel
  - [ ] Adicionar interface para re-autoriza√ß√£o manual
  - [ ] Configurar webhooks para mudan√ßas de status de consentimento

- [ ] **Sistema de Auditoria** (AC: 4)
  - [ ] Criar tabela de logs de conex√£o no Supabase
  - [ ] Implementar logging estruturado com metadados completos
  - [ ] Adicionar assinatura digital nos logs cr√≠ticos
  - [ ] Criar dashboard interno para monitoramento de conex√µes
  - [ ] Implementar alertas para atividades suspeitas

- [ ] **Testes e Valida√ß√£o** (AC: 5, 6, 7, 8)
  - [ ] Criar suite de testes para cada institui√ß√£o banc√°ria
  - [ ] Implementar testes de falha e recupera√ß√£o
  - [ ] Adicionar testes de performance e timeout
  - [ ] Validar conformidade com padr√µes Open Banking Brasil
  - [ ] Criar testes de carga para m√∫ltiplas conex√µes simult√¢neas

---

## Dev Notes

### Arquitetura Relevante

**Estrutura Atual:**
- `src/lib/banking/belvoApi.ts` - Cliente Belvo (stub implementado)
- `src/integrations/supabase/client.ts` - Cliente Supabase configurado
- `src/server/context.ts` - Contexto de autentica√ß√£o tRPC

**Novos Arquivos Necess√°rios:**
- `src/lib/banking/bankConnectors.ts` - Gerenciador de conectores
- `src/lib/banking/tokenManager.ts` - Gerenciamento seguro de tokens
- `src/lib/banking/auditLogger.ts` - Sistema de auditoria
- `src/lib/banking/errorHandler.ts` - Tratamento de erros espec√≠ficos por banco
- `src/server/procedures/banking.ts` - Procedures tRPC para banking

### Error Codes Espec√≠ficos por Banco

**C√≥digos de Erro Padronizados:**
```typescript
// src/lib/banking/errorHandler.ts
enum BankingErrorCode {
  // Erros de Conectividade
  NETWORK_TIMEOUT = 'NETWORK_TIMEOUT',
  CONNECTION_REFUSED = 'CONNECTION_REFUSED',
  DNS_RESOLUTION_FAILED = 'DNS_RESOLUTION_FAILED',

  // Erros de Autentica√ß√£o
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  CONSENT_REVOKED = 'CONSENT_REVOKED',
  MFA_REQUIRED = 'MFA_REQUIRED',
  ACCOUNT_LOCKED = 'ACCOUNT_LOCKED',

  // Erros de Rate Limiting
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  DAILY_LIMIT_REACHED = 'DAILY_LIMIT_REACHED',
  CONCURRENT_LIMIT_EXCEEDED = 'CONCURRENT_LIMIT_EXCEEDED',

  // Erros de Dados
  ACCOUNT_NOT_FOUND = 'ACCOUNT_NOT_FOUND',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
  DATA_UNAVAILABLE = 'DATA_UNAVAILABLE',
  INVALID_DATE_RANGE = 'INVALID_DATE_RANGE',

  // Erros do Banco
  BANK_MAINTENANCE = 'BANK_MAINTENANCE',
  BANK_SYSTEM_ERROR = 'BANK_SYSTEM_ERROR',
  BANK_TIMEOUT = 'BANK_TIMEOUT',

  // Erros da Belvo
  BELVO_API_ERROR = 'BELVO_API_ERROR',
  BELVO_RATE_LIMIT = 'BELVO_RATE_LIMIT',
  BELVO_MAINTENANCE = 'BELVO_MAINTENANCE'
}

interface BankErrorMapping {
  [bankCode: string]: {
    [originalError: string]: {
      code: BankingErrorCode;
      userMessage: string;
      retryStrategy: RetryStrategy;
      severity: 'low' | 'medium' | 'high' | 'critical';
    };
  };
}

const BANK_ERROR_MAPPINGS: BankErrorMapping = {
  // Ita√∫
  'itau': {
    'CONN_TIMEOUT': {
      code: BankingErrorCode.NETWORK_TIMEOUT,
      userMessage: 'Conex√£o com o Ita√∫ demorou mais que o esperado. Tentando novamente...',
      retryStrategy: { maxRetries: 3, backoffMs: 2000, exponential: true },
      severity: 'medium'
    },
    'AUTH_FAILED': {
      code: BankingErrorCode.INVALID_CREDENTIALS,
      userMessage: 'Credenciais do Ita√∫ inv√°lidas. Verifique seus dados de acesso.',
      retryStrategy: { maxRetries: 0, backoffMs: 0, exponential: false },
      severity: 'high'
    },
    'RATE_LIMIT': {
      code: BankingErrorCode.RATE_LIMIT_EXCEEDED,
      userMessage: 'Muitas tentativas no Ita√∫. Aguarde 5 minutos antes de tentar novamente.',
      retryStrategy: { maxRetries: 1, backoffMs: 300000, exponential: false }, // 5 min
      severity: 'medium'
    }
  },

  // Bradesco
  'bradesco': {
    'SYSTEM_UNAVAILABLE': {
      code: BankingErrorCode.BANK_MAINTENANCE,
      userMessage: 'Sistema do Bradesco em manuten√ß√£o. Tentaremos novamente em alguns minutos.',
      retryStrategy: { maxRetries: 5, backoffMs: 60000, exponential: true }, // 1 min base
      severity: 'medium'
    },
    'TOKEN_INVALID': {
      code: BankingErrorCode.TOKEN_EXPIRED,
      userMessage: 'Acesso ao Bradesco expirou. Reconectando automaticamente...',
      retryStrategy: { maxRetries: 1, backoffMs: 1000, exponential: false },
      severity: 'low'
    }
  },

  // Banco do Brasil
  'bb': {
    'MFA_CHALLENGE': {
      code: BankingErrorCode.MFA_REQUIRED,
      userMessage: 'Banco do Brasil requer autentica√ß√£o adicional. Verifique seu celular.',
      retryStrategy: { maxRetries: 0, backoffMs: 0, exponential: false },
      severity: 'high'
    },
    'CONCURRENT_ACCESS': {
      code: BankingErrorCode.CONCURRENT_LIMIT_EXCEEDED,
      userMessage: 'Voc√™ j√° est√° conectado ao BB em outro dispositivo. Desconecte e tente novamente.',
      retryStrategy: { maxRetries: 2, backoffMs: 30000, exponential: false }, // 30s
      severity: 'medium'
    }
  },

  // Santander
  'santander': {
    'ACCOUNT_BLOCKED': {
      code: BankingErrorCode.ACCOUNT_LOCKED,
      userMessage: 'Conta Santander temporariamente bloqueada. Entre em contato com o banco.',
      retryStrategy: { maxRetries: 0, backoffMs: 0, exponential: false },
      severity: 'critical'
    },
    'DATA_NOT_AVAILABLE': {
      code: BankingErrorCode.DATA_UNAVAILABLE,
      userMessage: 'Dados n√£o dispon√≠veis no Santander no momento. Tentando novamente...',
      retryStrategy: { maxRetries: 3, backoffMs: 5000, exponential: true },
      severity: 'low'
    }
  },

  // Caixa
  'caixa': {
    'MAINTENANCE_WINDOW': {
      code: BankingErrorCode.BANK_MAINTENANCE,
      userMessage: 'Caixa em manuten√ß√£o programada (22h-6h). Dados ser√£o atualizados pela manh√£.',
      retryStrategy: { maxRetries: 1, backoffMs: 28800000, exponential: false }, // 8h
      severity: 'low'
    },
    'SLOW_RESPONSE': {
      code: BankingErrorCode.BANK_TIMEOUT,
      userMessage: 'Sistema da Caixa lento. Aguarde, estamos processando...',
      retryStrategy: { maxRetries: 2, backoffMs: 10000, exponential: true },
      severity: 'medium'
    }
  }
};

interface RetryStrategy {
  maxRetries: number;
  backoffMs: number;
  exponential: boolean;
}

class BankingErrorHandler {
  private errorMappings: BankErrorMapping;

  constructor() {
    this.errorMappings = BANK_ERROR_MAPPINGS;
  }

  handleBankError(bankCode: string, originalError: string, context: ErrorContext): BankingError {
    // 1. Mapear erro espec√≠fico do banco
    const bankMapping = this.errorMappings[bankCode];
    const errorMapping = bankMapping?.[originalError];

    if (errorMapping) {
      return {
        code: errorMapping.code,
        message: errorMapping.userMessage,
        originalError,
        bankCode,
        retryStrategy: errorMapping.retryStrategy,
        severity: errorMapping.severity,
        context,
        timestamp: new Date(),
        canRetry: errorMapping.retryStrategy.maxRetries > 0
      };
    }

    // 2. Fallback para erro gen√©rico
    return this.createGenericError(bankCode, originalError, context);
  }

  async executeWithRetry<T>(
    operation: () => Promise<T>,
    retryStrategy: RetryStrategy,
    errorHandler: (error: any, attempt: number) => boolean = () => true
  ): Promise<T> {
    let lastError: any;

    for (let attempt = 0; attempt <= retryStrategy.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;

        // Verificar se deve tentar novamente
        if (attempt === retryStrategy.maxRetries || !errorHandler(error, attempt)) {
          break;
        }

        // Calcular delay
        const delay = retryStrategy.exponential
          ? retryStrategy.backoffMs * Math.pow(2, attempt)
          : retryStrategy.backoffMs;

        console.log(`Tentativa ${attempt + 1} falhou. Tentando novamente em ${delay}ms...`);
        await this.sleep(delay);
      }
    }

    throw lastError;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Exemplo de uso
const errorHandler = new BankingErrorHandler();

try {
  const accounts = await errorHandler.executeWithRetry(
    () => belvoClient.getAccounts(institutionId),
    { maxRetries: 3, backoffMs: 2000, exponential: true },
    (error, attempt) => {
      // S√≥ retry em erros tempor√°rios
      return error.code !== BankingErrorCode.INVALID_CREDENTIALS;
    }
  );
} catch (error) {
  const bankingError = errorHandler.handleBankError('itau', error.message, {
    userId,
    institutionId,
    operation: 'getAccounts'
  });

  // Mostrar mensagem amig√°vel para o usu√°rio
  toast.error(bankingError.message);

  // Log t√©cnico para debugging
  console.error('Banking operation failed:', bankingError);
}
```

### Estrat√©gias de Retry por Tipo de Erro

**Configura√ß√£o de Retry Inteligente:**
```typescript
// src/lib/banking/retryStrategies.ts
const RETRY_STRATEGIES = {
  // Erros tempor√°rios - retry agressivo
  [BankingErrorCode.NETWORK_TIMEOUT]: {
    maxRetries: 3,
    backoffMs: 1000,
    exponential: true,
    jitter: true // Adiciona aleatoriedade para evitar thundering herd
  },

  // Rate limiting - retry com delay longo
  [BankingErrorCode.RATE_LIMIT_EXCEEDED]: {
    maxRetries: 2,
    backoffMs: 60000, // 1 minuto
    exponential: false,
    jitter: false
  },

  // Manuten√ß√£o do banco - retry com delay muito longo
  [BankingErrorCode.BANK_MAINTENANCE]: {
    maxRetries: 1,
    backoffMs: 1800000, // 30 minutos
    exponential: false,
    jitter: true
  },

  // Erros de autentica√ß√£o - n√£o retry
  [BankingErrorCode.INVALID_CREDENTIALS]: {
    maxRetries: 0,
    backoffMs: 0,
    exponential: false,
    jitter: false
  },

  // Token expirado - retry imediato ap√≥s refresh
  [BankingErrorCode.TOKEN_EXPIRED]: {
    maxRetries: 1,
    backoffMs: 500,
    exponential: false,
    jitter: false
  }
};
```

### Mensagens de Erro para Usu√°rio

**Templates de Mensagem por Contexto:**
```typescript
const USER_ERROR_MESSAGES = {
  [BankingErrorCode.NETWORK_TIMEOUT]: {
    title: 'Conex√£o Lenta',
    message: 'A conex√£o com seu banco est√° mais lenta que o normal. Estamos tentando novamente...',
    action: 'Aguarde alguns segundos',
    icon: '‚è≥'
  },

  [BankingErrorCode.INVALID_CREDENTIALS]: {
    title: 'Dados de Acesso Inv√°lidos',
    message: 'N√£o conseguimos acessar sua conta banc√°ria. Verifique se seus dados est√£o corretos.',
    action: 'Reconectar Banco',
    icon: 'üîê'
  },

  [BankingErrorCode.BANK_MAINTENANCE]: {
    title: 'Banco em Manuten√ß√£o',
    message: 'Seu banco est√° em manuten√ß√£o programada. Seus dados ser√£o atualizados assim que poss√≠vel.',
    action: 'Tentar Mais Tarde',
    icon: 'üîß'
  },

  [BankingErrorCode.RATE_LIMIT_EXCEEDED]: {
    title: 'Muitas Tentativas',
    message: 'Fizemos muitas consultas ao seu banco recentemente. Aguarde alguns minutos.',
    action: 'Aguardar 5 minutos',
    icon: '‚è±Ô∏è'
  }
};
```

**Schema do Supabase:**
```sql
-- Tabela para conex√µes banc√°rias
CREATE TABLE bank_connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  institution_id TEXT NOT NULL,
  institution_name TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('active', 'expired', 'revoked', 'error')),
  consent_expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Tabela para logs de auditoria
CREATE TABLE banking_audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  action TEXT NOT NULL,
  institution_id TEXT,
  metadata JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
```

### Configura√ß√µes de Seguran√ßa

**Vari√°veis de Ambiente Necess√°rias:**
- `BELVO_API_KEY` - Chave da API Belvo
- `BELVO_SECRET_KEY` - Chave secreta Belvo
- `BANKING_ENCRYPTION_KEY` - Chave para criptografia de tokens
- `OPEN_BANKING_WEBHOOK_SECRET` - Secret para valida√ß√£o de webhooks

**Pol√≠ticas RLS:**
- Usu√°rios s√≥ podem ver suas pr√≥prias conex√µes banc√°rias
- Logs de auditoria isolados por usu√°rio
- Tokens criptografados nunca expostos via API

### Testing

**Localiza√ß√£o:** `src/test/banking/connectors/`
**Frameworks:** Vitest para l√≥gica, Playwright para fluxos OAuth
**Ambientes de Teste:**
- Sandbox Belvo para testes automatizados
- Mock servers para testes de falha
- Ambiente de homologa√ß√£o com bancos reais

**Cen√°rios de Teste Cr√≠ticos:**
- Conex√£o bem-sucedida com cada banco
- Falha de autentica√ß√£o e recupera√ß√£o
- Expira√ß√£o de token e renova√ß√£o
- Revoga√ß√£o de consentimento pelo usu√°rio
- Indisponibilidade tempor√°ria do banco

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0.0 | Cria√ß√£o inicial da story | PM Agent "John" |
| 2025-10-04 | 1.1.0 | Refinamento p√≥s-valida√ß√£o PO: Adicionados error codes espec√≠ficos por banco (Ita√∫, Bradesco, BB, Santander, Caixa), estrat√©gias de retry inteligente por tipo de erro, mensagens de usu√°rio contextuais | SM Agent |

---

## Dev Agent Record

*Esta se√ß√£o ser√° preenchida pelo agente de desenvolvimento durante a implementa√ß√£o*

### Agent Model Used
*TBD*

### Debug Log References
*TBD*

### Completion Notes List
*TBD*

### File List
*TBD*

---

## QA Results

*Esta se√ß√£o ser√° preenchida pelo agente de QA ap√≥s revis√£o da implementa√ß√£o*